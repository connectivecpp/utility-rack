<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Utility Rack Reference: chops::wait_queue&lt; T, Container &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Utility Rack Reference
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>chops</b></li><li class="navelem"><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classchops_1_1wait__queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">chops::wait_queue&lt; T, Container &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afc28778bc46f3d5cf32244d46d960a53"><td class="memItemLeft" align="right" valign="top"><a id="afc28778bc46f3d5cf32244d46d960a53"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename Container::size_type</td></tr>
<tr class="separator:afc28778bc46f3d5cf32244d46d960a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a61f68b695ad1b1c03c0b9866021252"><td class="memItemLeft" align="right" valign="top"><a id="a3a61f68b695ad1b1c03c0b9866021252"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="separator:a3a61f68b695ad1b1c03c0b9866021252"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3a7c6ff751cfbb9036af8628a825f83b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a3a7c6ff751cfbb9036af8628a825f83b">wait_queue</a> ()</td></tr>
<tr class="memdesc:a3a7c6ff751cfbb9036af8628a825f83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>.  <a href="#a3a7c6ff751cfbb9036af8628a825f83b">More...</a><br /></td></tr>
<tr class="separator:a3a7c6ff751cfbb9036af8628a825f83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1fe1774e81f1e172c67cf1bc3eb293"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a9a1fe1774e81f1e172c67cf1bc3eb293"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a9a1fe1774e81f1e172c67cf1bc3eb293">wait_queue</a> (Iter beg, Iter end)</td></tr>
<tr class="memdesc:a9a1fe1774e81f1e172c67cf1bc3eb293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> with an iterator range for the container.  <a href="#a9a1fe1774e81f1e172c67cf1bc3eb293">More...</a><br /></td></tr>
<tr class="separator:a9a1fe1774e81f1e172c67cf1bc3eb293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e83506cd58f667c0acf0fbb7e69b06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#aa0e83506cd58f667c0acf0fbb7e69b06">wait_queue</a> (size_type sz)</td></tr>
<tr class="memdesc:aa0e83506cd58f667c0acf0fbb7e69b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> with an initial size or capacity.  <a href="#aa0e83506cd58f667c0acf0fbb7e69b06">More...</a><br /></td></tr>
<tr class="separator:aa0e83506cd58f667c0acf0fbb7e69b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96257d34c4045403dd80bf4d1fad90c"><td class="memItemLeft" align="right" valign="top"><a id="af96257d34c4045403dd80bf4d1fad90c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>wait_queue</b> (const <a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;)=delete</td></tr>
<tr class="separator:af96257d34c4045403dd80bf4d1fad90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143d87a02f76253b5a2149fd3418f44a"><td class="memItemLeft" align="right" valign="top"><a id="a143d87a02f76253b5a2149fd3418f44a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>wait_queue</b> (<a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a143d87a02f76253b5a2149fd3418f44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc973773ae7bfdc237489bf85271ce0"><td class="memItemLeft" align="right" valign="top"><a id="aacc973773ae7bfdc237489bf85271ce0"></a>
<a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;)=delete</td></tr>
<tr class="separator:aacc973773ae7bfdc237489bf85271ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913cca36683a962ed5fd87ab471498a1"><td class="memItemLeft" align="right" valign="top"><a id="a913cca36683a962ed5fd87ab471498a1"></a>
<a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a913cca36683a962ed5fd87ab471498a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f332b7b4f12105be86402ae5c88e1d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a2f332b7b4f12105be86402ae5c88e1d5">open</a> () noexcept</td></tr>
<tr class="memdesc:a2f332b7b4f12105be86402ae5c88e1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a previously closed <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> for processing.  <a href="#a2f332b7b4f12105be86402ae5c88e1d5">More...</a><br /></td></tr>
<tr class="separator:a2f332b7b4f12105be86402ae5c88e1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b66936ca95b2160882953cc7e6f109a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a9b66936ca95b2160882953cc7e6f109a">close</a> ()</td></tr>
<tr class="memdesc:a9b66936ca95b2160882953cc7e6f109a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> for processing.  <a href="#a9b66936ca95b2160882953cc7e6f109a">More...</a><br /></td></tr>
<tr class="separator:a9b66936ca95b2160882953cc7e6f109a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219bd031684bb9ba57a5a0a44684ff47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a219bd031684bb9ba57a5a0a44684ff47">push</a> (const T &amp;val)</td></tr>
<tr class="memdesc:a219bd031684bb9ba57a5a0a44684ff47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a value, by copying, to the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>.  <a href="#a219bd031684bb9ba57a5a0a44684ff47">More...</a><br /></td></tr>
<tr class="separator:a219bd031684bb9ba57a5a0a44684ff47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e84bd97d3cb1524beed9112206141e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a35e84bd97d3cb1524beed9112206141e">push</a> (T &amp;&amp;val)</td></tr>
<tr class="memdesc:a35e84bd97d3cb1524beed9112206141e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a value, either by moving or copying, to the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>.  <a href="#a35e84bd97d3cb1524beed9112206141e">More...</a><br /></td></tr>
<tr class="separator:a35e84bd97d3cb1524beed9112206141e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7122b2ffbfa2a5e1b90ea05c3524c8db"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a7122b2ffbfa2a5e1b90ea05c3524c8db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a7122b2ffbfa2a5e1b90ea05c3524c8db">emplace_push</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7122b2ffbfa2a5e1b90ea05c3524c8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly construct an object in the underlying container (using the container's <code>emplace_back</code> method) by forwarding the supplied arguments (can be more than one).  <a href="#a7122b2ffbfa2a5e1b90ea05c3524c8db">More...</a><br /></td></tr>
<tr class="separator:a7122b2ffbfa2a5e1b90ea05c3524c8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b57c6c15fbd38823e1c0c712cbbc768"><td class="memItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a7b57c6c15fbd38823e1c0c712cbbc768">wait_and_pop</a> ()</td></tr>
<tr class="memdesc:a7b57c6c15fbd38823e1c0c712cbbc768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop and return a value from the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>, blocking and waiting for a writer thread to push a value if one is not immediately available.  <a href="#a7b57c6c15fbd38823e1c0c712cbbc768">More...</a><br /></td></tr>
<tr class="separator:a7b57c6c15fbd38823e1c0c712cbbc768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46a6f37ff388826150377571d52604a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#ad46a6f37ff388826150377571d52604a">try_pop</a> ()</td></tr>
<tr class="memdesc:ad46a6f37ff388826150377571d52604a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop and return a value from the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> if an element is immediately available, otherwise return an empty <code>std::optional</code>.  <a href="#ad46a6f37ff388826150377571d52604a">More...</a><br /></td></tr>
<tr class="separator:ad46a6f37ff388826150377571d52604a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df31efd3da2dd14149a4b9856a86b20"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a1df31efd3da2dd14149a4b9856a86b20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a1df31efd3da2dd14149a4b9856a86b20">apply</a> (F &amp;&amp;func) const</td></tr>
<tr class="memdesc:a1df31efd3da2dd14149a4b9856a86b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a non-modifying function object to all elements of the queue.  <a href="#a1df31efd3da2dd14149a4b9856a86b20">More...</a><br /></td></tr>
<tr class="separator:a1df31efd3da2dd14149a4b9856a86b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0a90ae17c86b8ce6933ebae965c7ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#acd0a90ae17c86b8ce6933ebae965c7ea">is_closed</a> () const noexcept</td></tr>
<tr class="separator:acd0a90ae17c86b8ce6933ebae965c7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8580fff919a1beee237c2f0d6c8bf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a8e8580fff919a1beee237c2f0d6c8bf3">empty</a> () const</td></tr>
<tr class="separator:a8e8580fff919a1beee237c2f0d6c8bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b54f710b34a83e746b9b6feca0f89f"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#aa6b54f710b34a83e746b9b6feca0f89f">size</a> () const</td></tr>
<tr class="separator:aa6b54f710b34a83e746b9b6feca0f89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3a7c6ff751cfbb9036af8628a825f83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7c6ff751cfbb9036af8628a825f83b">&#9670;&nbsp;</a></span>wait_queue() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::<a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>. </p>
<dl class="section note"><dt>Note</dt><dd>A default constructed <code>boost</code> <code>circular_buffer</code> cannot do anything, so a different <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> constructor must be used if instantiated with a <code>boost</code> <code>circular_buffer</code>. </dd></dl>

</div>
</div>
<a id="a9a1fe1774e81f1e172c67cf1bc3eb293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1fe1774e81f1e172c67cf1bc3eb293">&#9670;&nbsp;</a></span>wait_queue() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::deque&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::<a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> with an iterator range for the container. </p>
<p>Construct the container (or container view) with an iterator range. Whether element copies are performed depends on the container type. Most container types copy initial elements as defined by the range and the initial size is set accordingly. A <code>ring_span</code>, however, uses the range distance to define a capacity and sets the initial size to zero.</p>
<dl class="section note"><dt>Note</dt><dd>This is the only constructor that can be used with a <code>ring_span</code> container type.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>Beginning iterator.</td></tr>
    <tr><td class="paramname">end</td><td>Ending iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0e83506cd58f667c0acf0fbb7e69b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e83506cd58f667c0acf0fbb7e69b06">&#9670;&nbsp;</a></span>wait_queue() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::<a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> with an initial size or capacity. </p>
<p>Construct the container (or container view) with an initial size of default inserted elements or with an initial capacity, depending on the container type.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor cannot be used with a <code>ring_span</code> container type.</dd>
<dd>
Using this constructor with a <code>boost</code> <code>circular_buffer</code> creates a container with the specified capacity, but an initial empty size.</dd>
<dd>
Using this constructor with most standard library container types creates a container initialized with default inserted elements.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>Capacity or initial size, depending on container type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1df31efd3da2dd14149a4b9856a86b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df31efd3da2dd14149a4b9856a86b20">&#9670;&nbsp;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::deque&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a non-modifying function object to all elements of the queue. </p>
<p>The function object is not allowed to modify any of the elements. The supplied function object is passed a const reference to the element type.</p>
<p>This method can be used when an iteration of the elements is needed, such as to print the elements, or copy them to another container, or to interrogate values of the elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function object to be invoked on each element. The function object should have the signature: <div class="fragment"><div class="line">void (<span class="keyword">const</span> T&amp;);</div></div><!-- fragment --> where <code>T</code> is the type of element in the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The entire <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> is locked while <code>apply</code> is in process, so passing in a function object that blocks or takes a lot of processing time may result in slow performance.</dd>
<dd>
It is undefined behavior if the function object calls into the same <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> since it results in recursive mutex locks. </dd></dl>

</div>
</div>
<a id="a9b66936ca95b2160882953cc7e6f109a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b66936ca95b2160882953cc7e6f109a">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> for processing. </p>
<p>When this method is called, all waiting reader threaders will be notified. Subsequent <code>push</code> operations will return <code>false</code>. </p>

</div>
</div>
<a id="a7122b2ffbfa2a5e1b90ea05c3524c8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7122b2ffbfa2a5e1b90ea05c3524c8db">&#9670;&nbsp;</a></span>emplace_push()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::deque&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::emplace_push </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Directly construct an object in the underlying container (using the container's <code>emplace_back</code> method) by forwarding the supplied arguments (can be more than one). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments to be used in constructing an element at the end of the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <code>std</code> containers return a reference to the newly constructed element from <code>emplace</code> method calls. <code>emplace_push</code> for a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> does not follow this convention and instead has the same return as the <code>push</code> methods.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if successful, <code>false</code> if the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> is closed. </dd></dl>

</div>
</div>
<a id="a8e8580fff919a1beee237c2f0d6c8bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8580fff919a1beee237c2f0d6c8bf3">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query whether the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> is empty or not.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> is empty. </dd></dl>

</div>
</div>
<a id="acd0a90ae17c86b8ce6933ebae965c7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0a90ae17c86b8ce6933ebae965c7ea">&#9670;&nbsp;</a></span>is_closed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::is_closed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query whether the @ close method has been called on the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> has been closed. </dd></dl>

</div>
</div>
<a id="a2f332b7b4f12105be86402ae5c88e1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f332b7b4f12105be86402ae5c88e1d5">&#9670;&nbsp;</a></span>open()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open a previously closed <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> for processing. </p>
<dl class="section note"><dt>Note</dt><dd>The initial state of a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> is open. </dd></dl>

</div>
</div>
<a id="a219bd031684bb9ba57a5a0a44684ff47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219bd031684bb9ba57a5a0a44684ff47">&#9670;&nbsp;</a></span>push() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push a value, by copying, to the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>. </p>
<p>When a value is pushed, one waiting reader thread (if any) will be notified that a value has been added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Val to copy into the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if successful, <code>false</code> if the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> is closed. </dd></dl>

</div>
</div>
<a id="a35e84bd97d3cb1524beed9112206141e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e84bd97d3cb1524beed9112206141e">&#9670;&nbsp;</a></span>push() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::push </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push a value, either by moving or copying, to the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>. </p>
<p>This method has the same semantics as the other <code>push</code>, except that the value will be moved (if possible) instead of copied. </p>

</div>
</div>
<a id="aa6b54f710b34a83e746b9b6feca0f89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b54f710b34a83e746b9b6feca0f89f">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of elements in the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements in the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>. </dd></dl>

</div>
</div>
<a id="ad46a6f37ff388826150377571d52604a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46a6f37ff388826150377571d52604a">&#9670;&nbsp;</a></span>try_pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;T&gt; <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::try_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop and return a value from the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> if an element is immediately available, otherwise return an empty <code>std::optional</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A value from the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> or an empty <code>std::optional</code> if no values are available in the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>. </dd></dl>

</div>
</div>
<a id="a7b57c6c15fbd38823e1c0c712cbbc768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b57c6c15fbd38823e1c0c712cbbc768">&#9670;&nbsp;</a></span>wait_and_pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;T&gt; <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::wait_and_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop and return a value from the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>, blocking and waiting for a writer thread to push a value if one is not immediately available. </p>
<p>If this method is called after a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> has been closed, an empty <code>std::optional</code> is returned. If a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> needs to be flushed after it is closed, <code>try_pop</code> should be called instead.</p>
<dl class="section return"><dt>Returns</dt><dd>A value from the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> (if non-empty). If the <code>std::optional</code> is empty, the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> has been closed. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/queue/<a class="el" href="wait__queue_8hpp_source.html">wait_queue.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
