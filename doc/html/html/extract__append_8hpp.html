<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Utility Rack Reference: include/marshall/extract_append.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Utility Rack Reference
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_e31551851e0e6b7c063ad179dd9ad94a.html">marshall</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">extract_append.hpp File Reference<div class="ingroups"><a class="el" href="group__marshall__module.html">Classes and functions for big-endian binary data</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions to extract arithmetic binary values from a byte buffer (in big-endian) to native format; conversely, given an arithmetic binary value, append it to a buffer of bytes in network endian order (big-endian).  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="cast__ptr__to_8hpp_source.html">utility/cast_ptr_to.hpp</a>&quot;</code><br />
<code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for extract_append.hpp:</div>
<div class="dyncontent">
<div class="center"><img src="extract__append_8hpp__incl.png" border="0" usemap="#include_2marshall_2extract__append_8hpp" alt=""/></div>
<map name="include_2marshall_2extract__append_8hpp" id="include_2marshall_2extract__append_8hpp">
<area shape="rect" id="node2" href="cast__ptr__to_8hpp.html" title="utility/cast_ptr_to.hpp" alt="" coords="5,95,152,121"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="extract__append_8hpp__dep__incl.png" border="0" usemap="#include_2marshall_2extract__append_8hppdep" alt=""/></div>
<map name="include_2marshall_2extract__append_8hppdep" id="include_2marshall_2extract__append_8hppdep">
<area shape="rect" id="node2" href="marshall_8hpp.html" title="include/marshall/marshall.hpp" alt="" coords="5,95,200,121"/>
</map>
</div>
</div>
<p><a href="extract__append_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structchops_1_1detail_1_1size__tag.html">chops::detail::size_tag&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a381b87ec22420930bcadf6261951155e"><td class="memTemplParams" colspan="2"><a id="a381b87ec22420930bcadf6261951155e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a381b87ec22420930bcadf6261951155e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::extract_val_swap</b> (const std::byte *buf, const size_tag&lt; 1u &gt; *) noexcept</td></tr>
<tr class="separator:a381b87ec22420930bcadf6261951155e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e044dc5d74595457cf44eb2653c4d4"><td class="memTemplParams" colspan="2"><a id="a82e044dc5d74595457cf44eb2653c4d4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a82e044dc5d74595457cf44eb2653c4d4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::extract_val_noswap</b> (const std::byte *buf, const size_tag&lt; 1u &gt; *) noexcept</td></tr>
<tr class="separator:a82e044dc5d74595457cf44eb2653c4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9d85822512d200ac324fd7a714ba1d"><td class="memTemplParams" colspan="2"><a id="adf9d85822512d200ac324fd7a714ba1d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adf9d85822512d200ac324fd7a714ba1d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::extract_val_swap</b> (const std::byte *buf, const size_tag&lt; 2u &gt; *) noexcept</td></tr>
<tr class="separator:adf9d85822512d200ac324fd7a714ba1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74bbda756a1db177cd468019937360b"><td class="memTemplParams" colspan="2"><a id="ab74bbda756a1db177cd468019937360b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab74bbda756a1db177cd468019937360b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::extract_val_noswap</b> (const std::byte *buf, const size_tag&lt; 2u &gt; *) noexcept</td></tr>
<tr class="separator:ab74bbda756a1db177cd468019937360b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341bea9ebbf7a106bbc1ee3cf4edf8a2"><td class="memTemplParams" colspan="2"><a id="a341bea9ebbf7a106bbc1ee3cf4edf8a2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a341bea9ebbf7a106bbc1ee3cf4edf8a2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::extract_val_swap</b> (const std::byte *buf, const size_tag&lt; 4u &gt; *) noexcept</td></tr>
<tr class="separator:a341bea9ebbf7a106bbc1ee3cf4edf8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a21e583a3121dd05f4da40e1e46255"><td class="memTemplParams" colspan="2"><a id="ad1a21e583a3121dd05f4da40e1e46255"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad1a21e583a3121dd05f4da40e1e46255"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::extract_val_noswap</b> (const std::byte *buf, const size_tag&lt; 4u &gt; *) noexcept</td></tr>
<tr class="separator:ad1a21e583a3121dd05f4da40e1e46255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9f0550e3f088eda6d2ea7a26533f8e"><td class="memTemplParams" colspan="2"><a id="aed9f0550e3f088eda6d2ea7a26533f8e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed9f0550e3f088eda6d2ea7a26533f8e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::extract_val_swap</b> (const std::byte *buf, const size_tag&lt; 8u &gt; *) noexcept</td></tr>
<tr class="separator:aed9f0550e3f088eda6d2ea7a26533f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb517e4ac91a27a858731eb56a64656"><td class="memTemplParams" colspan="2"><a id="a9eb517e4ac91a27a858731eb56a64656"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9eb517e4ac91a27a858731eb56a64656"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::extract_val_noswap</b> (const std::byte *buf, const size_tag&lt; 8u &gt; *) noexcept</td></tr>
<tr class="separator:a9eb517e4ac91a27a858731eb56a64656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e33e688d542b86bd4bbea33f604855"><td class="memTemplParams" colspan="2"><a id="a24e33e688d542b86bd4bbea33f604855"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24e33e688d542b86bd4bbea33f604855"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::extract_val_swap</b> (const std::byte *buf, const size_tag&lt; 16u &gt; *) noexcept</td></tr>
<tr class="separator:a24e33e688d542b86bd4bbea33f604855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d04b5e98c3cd6ed2c28e6833dc29e6"><td class="memTemplParams" colspan="2"><a id="a07d04b5e98c3cd6ed2c28e6833dc29e6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a07d04b5e98c3cd6ed2c28e6833dc29e6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::extract_val_noswap</b> (const std::byte *buf, const size_tag&lt; 16u &gt; *) noexcept</td></tr>
<tr class="separator:a07d04b5e98c3cd6ed2c28e6833dc29e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76823bf82435adbcd58b7775578fc69"><td class="memTemplParams" colspan="2"><a id="ab76823bf82435adbcd58b7775578fc69"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab76823bf82435adbcd58b7775578fc69"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::append_val_swap</b> (std::byte *buf, const T &amp;val, const size_tag&lt; 1u &gt; *) noexcept</td></tr>
<tr class="separator:ab76823bf82435adbcd58b7775578fc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd821c13a458facc8404ba9eb5d96f6"><td class="memTemplParams" colspan="2"><a id="a9fd821c13a458facc8404ba9eb5d96f6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9fd821c13a458facc8404ba9eb5d96f6"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::append_val_noswap</b> (std::byte *buf, const T &amp;val, const size_tag&lt; 1u &gt; *) noexcept</td></tr>
<tr class="separator:a9fd821c13a458facc8404ba9eb5d96f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39857d465114c45a420bdd93b973bde6"><td class="memTemplParams" colspan="2"><a id="a39857d465114c45a420bdd93b973bde6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a39857d465114c45a420bdd93b973bde6"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::append_val_swap</b> (std::byte *buf, const T &amp;val, const size_tag&lt; 2u &gt; *) noexcept</td></tr>
<tr class="separator:a39857d465114c45a420bdd93b973bde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8b80cad927342957f2ce17364585eb"><td class="memTemplParams" colspan="2"><a id="a5b8b80cad927342957f2ce17364585eb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5b8b80cad927342957f2ce17364585eb"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::append_val_noswap</b> (std::byte *buf, const T &amp;val, const size_tag&lt; 2u &gt; *) noexcept</td></tr>
<tr class="separator:a5b8b80cad927342957f2ce17364585eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7562f91b775f1835cbfffcbe8dc6e763"><td class="memTemplParams" colspan="2"><a id="a7562f91b775f1835cbfffcbe8dc6e763"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7562f91b775f1835cbfffcbe8dc6e763"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::append_val_swap</b> (std::byte *buf, const T &amp;val, const size_tag&lt; 4u &gt; *) noexcept</td></tr>
<tr class="separator:a7562f91b775f1835cbfffcbe8dc6e763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3f547a15f6816ae33b81a6364b34c6"><td class="memTemplParams" colspan="2"><a id="a7b3f547a15f6816ae33b81a6364b34c6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7b3f547a15f6816ae33b81a6364b34c6"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::append_val_noswap</b> (std::byte *buf, const T &amp;val, const size_tag&lt; 4u &gt; *) noexcept</td></tr>
<tr class="separator:a7b3f547a15f6816ae33b81a6364b34c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1feb6825a9ed1f37634d968c885d067f"><td class="memTemplParams" colspan="2"><a id="a1feb6825a9ed1f37634d968c885d067f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1feb6825a9ed1f37634d968c885d067f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::append_val_swap</b> (std::byte *buf, const T &amp;val, const size_tag&lt; 8u &gt; *) noexcept</td></tr>
<tr class="separator:a1feb6825a9ed1f37634d968c885d067f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b643bf64c555f00a75d93731ed6c0d"><td class="memTemplParams" colspan="2"><a id="ab1b643bf64c555f00a75d93731ed6c0d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1b643bf64c555f00a75d93731ed6c0d"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::append_val_noswap</b> (std::byte *buf, const T &amp;val, const size_tag&lt; 8u &gt; *) noexcept</td></tr>
<tr class="separator:ab1b643bf64c555f00a75d93731ed6c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add511d236607f841a37d9e06e8014635"><td class="memTemplParams" colspan="2"><a id="add511d236607f841a37d9e06e8014635"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:add511d236607f841a37d9e06e8014635"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::append_val_swap</b> (std::byte *buf, const T &amp;val, const size_tag&lt; 16u &gt; *) noexcept</td></tr>
<tr class="separator:add511d236607f841a37d9e06e8014635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb0719f42aa4be4220f40a19529524b"><td class="memTemplParams" colspan="2"><a id="a2cb0719f42aa4be4220f40a19529524b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2cb0719f42aa4be4220f40a19529524b"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::append_val_noswap</b> (std::byte *buf, const T &amp;val, const size_tag&lt; 16u &gt; *) noexcept</td></tr>
<tr class="separator:a2cb0719f42aa4be4220f40a19529524b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac760c0e24efe9622acf69b72d2a912e2"><td class="memTemplParams" colspan="2"><a id="ac760c0e24efe9622acf69b72d2a912e2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac760c0e24efe9622acf69b72d2a912e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::assert_size</b> () noexcept</td></tr>
<tr class="separator:ac760c0e24efe9622acf69b72d2a912e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3903ce0d9e11d2d12610daef1153097"><td class="memTemplParams" colspan="2"><a id="ae3903ce0d9e11d2d12610daef1153097"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae3903ce0d9e11d2d12610daef1153097"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::is_arithmetic_or_byte</b> () noexcept</td></tr>
<tr class="separator:ae3903ce0d9e11d2d12610daef1153097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7d00aa6f783d6ded148f2f39ba43f9"><td class="memTemplParams" colspan="2"><a id="acb7d00aa6f783d6ded148f2f39ba43f9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb7d00aa6f783d6ded148f2f39ba43f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chops::detail::assert_arithmetic_or_byte</b> () noexcept</td></tr>
<tr class="separator:acb7d00aa6f783d6ded148f2f39ba43f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568ec0d3a9d1f181ecb904a21dddd2b0"><td class="memItemLeft" align="right" valign="top"><a id="a568ec0d3a9d1f181ecb904a21dddd2b0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>chops::detect_big_endian</b> () noexcept</td></tr>
<tr class="separator:a568ec0d3a9d1f181ecb904a21dddd2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59bc2904ad9486a9b309bdebbd83ba2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab59bc2904ad9486a9b309bdebbd83ba2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="extract__append_8hpp.html#ab59bc2904ad9486a9b309bdebbd83ba2">chops::extract_val</a> (const std::byte *buf) noexcept</td></tr>
<tr class="memdesc:ab59bc2904ad9486a9b309bdebbd83ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a value in network byte order (big-endian) from a <code>std::byte</code> buffer into a fundamental arithmetic type in native endianness, swapping bytes as needed.  <a href="extract__append_8hpp.html#ab59bc2904ad9486a9b309bdebbd83ba2">More...</a><br /></td></tr>
<tr class="separator:ab59bc2904ad9486a9b309bdebbd83ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806139ac5f96fba4ef57452bcb3bcb01"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a806139ac5f96fba4ef57452bcb3bcb01"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="extract__append_8hpp.html#a806139ac5f96fba4ef57452bcb3bcb01">chops::append_val</a> (std::byte *buf, const T &amp;val) noexcept</td></tr>
<tr class="memdesc:a806139ac5f96fba4ef57452bcb3bcb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a fundamental arithmetic value to a <code>std::byte</code> buffer, swapping into network endian order (big-endian) as needed.  <a href="extract__append_8hpp.html#a806139ac5f96fba4ef57452bcb3bcb01">More...</a><br /></td></tr>
<tr class="separator:a806139ac5f96fba4ef57452bcb3bcb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9845dd8c4b9246615481a1c6f449b0f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae9845dd8c4b9246615481a1c6f449b0f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="extract__append_8hpp.html#ae9845dd8c4b9246615481a1c6f449b0f">chops::append_var_int</a> (std::byte *output, T val)</td></tr>
<tr class="memdesc:ae9845dd8c4b9246615481a1c6f449b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode an unsigned integer into a variable length buffer of bytes using the MSB (most significant bit) algorithm.  <a href="extract__append_8hpp.html#ae9845dd8c4b9246615481a1c6f449b0f">More...</a><br /></td></tr>
<tr class="separator:ae9845dd8c4b9246615481a1c6f449b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca0853fe2aff5f30398cf7087d31b07"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ca0853fe2aff5f30398cf7087d31b07"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="extract__append_8hpp.html#a9ca0853fe2aff5f30398cf7087d31b07">chops::extract_var_int</a> (const std::byte *input, std::size_t input_size)</td></tr>
<tr class="memdesc:a9ca0853fe2aff5f30398cf7087d31b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a buffer of <code>std::bytes</code> that hold a variable sized integer, decode them into an unsigned integer.  <a href="extract__append_8hpp.html#a9ca0853fe2aff5f30398cf7087d31b07">More...</a><br /></td></tr>
<tr class="separator:a9ca0853fe2aff5f30398cf7087d31b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae399e619334dea3d7b19dc2382bac66f"><td class="memItemLeft" align="right" valign="top"><a id="ae399e619334dea3d7b19dc2382bac66f"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>chops::big_endian</b> = detect_big_endian()</td></tr>
<tr class="separator:ae399e619334dea3d7b19dc2382bac66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions to extract arithmetic binary values from a byte buffer (in big-endian) to native format; conversely, given an arithmetic binary value, append it to a buffer of bytes in network endian order (big-endian). </p>
<p>The functions in this file are low-level, handling fundamental arithmetic types and extracting or appending to <code>std::byte</code> buffers. It is meant to be the lower layer of marshalling utilities, where the next layer up provides buffer management, sequences, and overloads for specific types such as <code>std::string</code>, <code>bool</code>, and <code>std::optional</code>.</p>
<dl class="section note"><dt>Note</dt><dd>When C++ 20 <code>std::endian</code> is available, many of these functions can be made <code>constexpr</code> and evaluated at compile time. Until then, run-time endian detection and copying is performed.</dd>
<dd>
The variable sized integer functions (<code>extract_var_int</code>, <code>append_var_int</code>) support the variable byte integer type in MQTT (Message Queuing Telemetry Transport), a commonly used IoT protocol. The code in this header is adapted from a Techoverflow.net article by Uli Koehler and published under the CC0 1.0 Universal license: <a href="https://techoverflow.net/2013/01/25/efficiently-encoding-variable-length-integers-in-cc/">https://techoverflow.net/2013/01/25/efficiently-encoding-variable-length-integers-in-cc/</a></dd>
<dd>
This implementation has manual generated unrolled loops for the byte moving and swapping. This can be improved in the future by using a compile-time unrolling utility, such as the <code>repeat</code> function (compile time unrolling version) by Vittorio Romeo.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Cliff Green, Roxanne Agerone, Uli Koehler</dd></dl>
<p>Copyright (c) 2019 by Cliff Green, Roxanne Agerone</p>
<p>Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>) </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="file_a806139ac5f96fba4ef57452bcb3bcb01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a806139ac5f96fba4ef57452bcb3bcb01">&#9670;&nbsp;</a></span>append_val()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t chops::append_val </td>
          <td>(</td>
          <td class="paramtype">std::byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a fundamental arithmetic value to a <code>std::byte</code> buffer, swapping into network endian order (big-endian) as needed. </p>
<p>This function template dispatches on specific sizes. If an unsupported size is attempted to be swapped, a static error is generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to array of <code>std::bytes</code> big enough to hold the bytes of the value.</td></tr>
    <tr><td class="paramname">val</td><td>Value in native endian order to append to buf.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes copied into the <code>std::byte</code> buffer.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The buffer must already be allocated to hold at least <code>sizeof(T)</code> bytes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>See note above about floating point values. </dd></dl>

</div>
</div>
<a id="file_ae9845dd8c4b9246615481a1c6f449b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_ae9845dd8c4b9246615481a1c6f449b0f">&#9670;&nbsp;</a></span>append_var_int()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t chops::append_var_int </td>
          <td>(</td>
          <td class="paramtype">std::byte *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode an unsigned integer into a variable length buffer of bytes using the MSB (most significant bit) algorithm. </p>
<p>Given an integer, store the value in 1 or 2 or 3 or more bytes depending on the value. If small (under 128) the value is stored in one byte. If the value is greater than 127, the most significant bit in the first byte is set to 1 and the value is stored in two bytes. This logic is repeated as necessary.</p>
<p>This algorithm optimizes space when most of the values are small. If most of the values are large, this algorithm is inefficient, needing more buffer space for the encoded integers than if fixed size integer buffers were used.</p>
<p>The output of this function is (by definition) in little-endian order (which is opposite to the rest of the <code>append</code> and <code>extract</code> functions). However, this does not matter since there is no byte swapping performed, and encoding and decoding will result in the native endianness of the platform.</p>
<dl class="section note"><dt>Note</dt><dd>Unsigned types are not supported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The input value. Any standard unsigned integer type is allowed.</td></tr>
    <tr><td class="paramname">output</td><td>A pointer to a preallocated array of <code>std::bytes</code> big enough for the output. A safe minimum size is 5 bytes for 32 bit integers, 10 bytes for 64 bit integers and 3 bytes for 16 bit integers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written to the output array.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The output buffer must already be allocated large enough to hold the result. </dd></dl>

</div>
</div>
<a id="file_ab59bc2904ad9486a9b309bdebbd83ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_ab59bc2904ad9486a9b309bdebbd83ba2">&#9670;&nbsp;</a></span>extract_val()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T chops::extract_val </td>
          <td>(</td>
          <td class="paramtype">const std::byte *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a value in network byte order (big-endian) from a <code>std::byte</code> buffer into a fundamental arithmetic type in native endianness, swapping bytes as needed. </p>
<p>This function template dispatches on specific sizes. If an unsupported size is attempted to be swapped, a compile time error is generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to an array of <code>std::bytes</code> containing an object of type T in network byte order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value in native endian order.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The buffer must contain at least <code>sizeof(T)</code> bytes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Floating point swapping is supported, but care must be taken. In particular, the floating point representation must exactly match on both sides of the marshalling (most modern processors use IEEE 754 floating point representations). A byte swapped floating point value cannot be directly accessed (e.g. passed by value), due to the bit patterns possibly representing NaN values, which can generate hardware traps, either causing runtime crashes or silently changing bits within the floating point number. An integer value, however, will always have valid bit patterns, even when byte swapped. </dd></dl>

</div>
</div>
<a id="file_a9ca0853fe2aff5f30398cf7087d31b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a9ca0853fe2aff5f30398cf7087d31b07">&#9670;&nbsp;</a></span>extract_var_int()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T chops::extract_var_int </td>
          <td>(</td>
          <td class="paramtype">const std::byte *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>input_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a buffer of <code>std::bytes</code> that hold a variable sized integer, decode them into an unsigned integer. </p>
<p>For consistency with the <code>append_var_int</code> function, only unsigned integers are supported for the output type of this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A variable-length encoded integer stored in a buffer of <code>std::bytes</code>.</td></tr>
    <tr><td class="paramname">input_size</td><td>Number of bytes representing the integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value in native unsigned integer format. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
