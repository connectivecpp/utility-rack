<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Utility Rack Reference: Classes and functions for big-endian binary data</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Utility Rack Reference
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a>  </div>
  <div class="headertitle">
<div class="title">Classes and functions for big-endian binary data</div>  </div>
</div><!--header-->
<div class="contents">

<p>Classes and functions to transform objects into a big-endian binary stream of bytes (marshall) and the converse (unmarshall), transform a stream of bytes into objects.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:extract__append_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="extract__append_8hpp.html">extract_append.hpp</a></td></tr>
<tr class="memdesc:extract__append_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions to extract arithmetic binary values from a byte buffer (in big-endian) to native format; conversely, given an arithmetic binary value, append it to a buffer of bytes in network endian order (big-endian). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:shared__buffer_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shared__buffer_8hpp.html">shared_buffer.hpp</a></td></tr>
<tr class="memdesc:shared__buffer_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference counted byte buffer classes, both const and mutable versions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Classes and functions to transform objects into a big-endian binary stream of bytes (marshall) and the converse (unmarshall), transform a stream of bytes into objects. </p>
<p>marshalling and unmarshalling (transform objects into and out of byte streams for transmission over a network or for file IO).</p>
<p>The <code>utility-rack</code> <code>marshall</code> and <code>unmarshall</code> functions and classes provide a simple and light abstraction for binary big-endian serialization. There are no message or element definitions, no embedded preprocesser syntax, and no extra build steps.</p>
<p>These facilities are useful when explicit control of every bit and byte is needed (and the wire protocol format is big-endian). Other marshalling and serialization designs have strengths and weaknesses (see higher level documentation for more explanation).</p>
<dl class="section note"><dt>Note</dt><dd>The design of the binary marshall and unmarshall functions is a good fit for a C++ metaprogamming implementation (using variadic templates). In particular, the primary design concept is a mapping of two (and sometimes three) types to a single value. A typelist would allow a single function (or method) call to operate on multiple values, instead of being forced to call the <code>marshall</code> or <code>unmarshall</code> function once for each value (or sequence). However, the first release uses the simpler (no metaprogramming, no variadic templates) implementation with a hope that a more sophisticated version will be available in the future.</dd></dl>
<p>The marshalling classes and functions are designed for networking (or file I/O), where binary data marshalling and unmarshalling is needed to send and receive messages (or to write or read defined portions of a file). Application code using this library has full control of every byte that is sent or received. Application objects are transformed into a <code>std::byte</code> buffer (and the converse) keeping a binary representation in network (big-endian) order.</p>
<p>For example, a 32-bit binary number (either a signed or unsigned integer) in native endian order will be transformed into four 8-bit bytes in network (big) endian order for sending over a network (or for file I/O). Conversely, the four 8-bit bytes in network endian order will be transformed back into the original 32-bit binary number when received (or read as file I/O). A <code>bool</code> can be transformed into either a 8-bit, 16-bit, 32-bit, or 64-bit number of either 1 or 0 (and back). A sequence (<code>std::vector</code> or array or other container) can be transformed into a count (8-bit, 16-bit, et al) followed by each element of the sequence. A <code>std::optional</code> can be transformed into a <code>bool</code> (8-bit, 16-bit, et al) followed by the value (if present).</p>
<p>No support is directly provided for higher level abstractions such as inheritance hierarchies, version numbers, type flags, or object relations. Pointers are also not directly supported (which would typically be part of an object relation). No specific wire protocol or data encoding is specified (other than big-endian). These higher level abstractions as well as "saving and later restoring a full application state" are better served by a library such as Boost Serialization or Google Protocol Buffers or Cap'n Proto.</p>
<p>There is not any automatic generation of message processing code (e.g. Google Protocol Buffers, a language neutral message definition process that generates marshalling and unmarshalling code). Future C++ standards supporting reflection may allow higher abstractions and more automation of marshalling code, but this library provides a modern C++ API (post C++ 11) for direct control of the byte buffers. In particular, all of the build process complications required for code generation are not present in this (header only) library.</p>
<p>Wire protocols that are in full text mode do not need to deal with binary endian swapping. However, sending or receiving data in a binary form is often desired for size efficiency (e.g. sending images and video, large data sets, or where the message size needs to be as small as possible).</p>
<p>Functionality is provided for fundamental types, including <code>bool</code>, as well as vocabulary types such as <code>std::string</code> and <code>std::optional</code>. Support is also provided for sequences, where the number of elements is placed before the element sequence in the stream of bytes.</p>
<p>Application defined types can be associated with a <code>marshall</code> and <code>unmarshall</code> function overload, providing a convenient way to reuse the same lower-level marshalling code. Specifically, a type <code>MyType</code> can be used in a sequence or in a <code>std::optional</code> or as part of a higher level <code>struct</code> or <code>class</code> type without needing to duplicate the marshalling calls within the <code>MyType</code> <code>marshall</code> and <code>unmarshall</code> functions.</p>
<p><code>std::variant</code> and <code>std::any</code> are not directly supported and require value extraction by the application. (Supporting <code>std::variant</code> or <code>std::any</code> might be a future enhancement if a good design is proposed.) <code>std::wstring</code> and other non-char strings are also not directly supported, and require additional calls from the application.</p>
<p>Central to the design of these marshalling and unmarshalling functions is a mapping of two types to a single value. For marshalling, the two types are the native type (e.g. <code>int</code>, <code>short</code>, <code>bool</code>), and the type to be used for the marshalling, typically a fixed width integer type, as specified in the <code></code> &lt;cstdint&gt; header (e.g. <code>std::uint32_t</code>, <code>std::int16_t</code>, <code>std::int8_t</code>). For unmarshalling, the same concept is used, a fixed width integer type that specifies the size in the byte buffer, and the native type, thus the application would specify that a <code>std::int16_t</code> in the byte buffer will be unmarshalled into an application <code>int</code> value.</p>
<dl class="section note"><dt>Note</dt><dd>No support is provided for little-endian in the byte buffer. No support is provided for mixed endian (big-endian with little-endian) or where the endianness is specified as a type parameter. No support is provided for "in-place" swapping of values. All of these use cases can be implemented using other libraries such as Boost Endian.</dd>
<dd>
Performance considerations - for marshalling, iterative resizing of the output buffer is a fundamental operation. <code>std::vector</code> and <code>mutable_shared_buffer</code> <code>resize</code> methods use efficient logic for internal buffer allocations (<code>mutable_shared_buffer</code> uses <code>std::vector</code> internally). Custom containers used as the buffer parameter should have similar efficient <code>resize</code> method logic. Calling <code>reserve</code> at appropriate places may provide a small performance increase, at the cost of additional requirements on the buffer type.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Cliff Green</dd></dl>
<p>Copyright (c) 2019 by Cliff Green</p>
<p>Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>) </p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
