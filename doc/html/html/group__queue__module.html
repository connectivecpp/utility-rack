<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Utility Rack Reference: Class and functions for various queue functionality.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Utility Rack Reference
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Class and functions for various queue functionality.</div>  </div>
</div><!--header-->
<div class="contents">

<p>Multi-reader multi-writer wait queue class for transferring data between threads.  
<a href="#details">More...</a></p>
<p>Multi-reader multi-writer wait queue class for transferring data between threads. </p>
<p>This class allows transferring data between threads with queue semantics (push, pop), using C++ std library general facilities (mutex, condition variable). An internal container is managed within this class.</p>
<p>Multiple writer and reader threads can access this object, although when a value is pushed, only one reader thread will be notified to consume a value.</p>
<p>One of the template parameters is the container type, allowing customization for specific use cases (see below for additional details).</p>
<p>If the <code>close</code> method is called, all reader threads calling <code>wait_and_pop</code> are notified, and an empty value returned to those threads. Subsequent calls to <code>push</code> will return a <code>false</code> value.</p>
<p>Example usage, default container:</p>
<div class="fragment"><div class="line"><a class="code" href="classchops_1_1wait__queue.html">chops::wait_queue&lt;int&gt;</a> wq;</div><div class="line"></div><div class="line"><span class="comment">// inside writer thread, assume wq passed in by reference</span></div><div class="line">wq.<a class="code" href="classchops_1_1wait__queue.html#a219bd031684bb9ba57a5a0a44684ff47">push</a>(42);</div><div class="line">...</div><div class="line"><span class="comment">// all finished, time to shutdown</span></div><div class="line">wq.close();</div><div class="line"></div><div class="line"><span class="comment">// inside reader thread, assume wq passed in by reference</span></div><div class="line"><span class="keyword">auto</span> rtn_val = wq.<a class="code" href="classchops_1_1wait__queue.html#a7b57c6c15fbd38823e1c0c712cbbc768">wait_and_pop</a>(); <span class="comment">// return type is std::optional&lt;int&gt;</span></div><div class="line"><span class="keywordflow">if</span> (!rtn_val) { <span class="comment">// empty value, close has been called</span></div><div class="line">  <span class="comment">// time to end reader thread</span></div><div class="line">}</div><div class="line"><span class="keywordflow">if</span> (*rtn_val == 42) ...</div></div><!-- fragment --><p>Example usage with ring buffer (from Martin Moene):</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> sz = 20;</div><div class="line"><span class="keywordtype">int</span> buf[sz];</div><div class="line"><a class="code" href="classchops_1_1wait__queue.html">chops::wait_queue&lt;int, nonstd::ring_span&lt;int&gt;</a> &gt; wq(buf+0, buf+sz);</div><div class="line"><span class="comment">// push and pop same as code with default container</span></div></div><!-- fragment --><p>The container type must support the following (depending on which methods are instantiated): default construction, construction from a begin and end iterator, construction with an initial size, <code>push_back</code> (preferably overloaded for both copy and move), <code>emplace_back</code> (with a template parameter pack), <code>front</code>, <code>pop_front</code>, <code>empty</code>, and <code>size</code>. The container must also have a <code>size_type</code> defined.</p>
<p>This class is based on code from the book Concurrency in Action by Anthony Williams. The core logic in this class is the same as provided by Anthony in his book, but the interfaces have changed and additional features added. The name of the utility class template in Anthony's book is <code>threadsafe_queue</code>.</p>
<dl class="section note"><dt>Note</dt><dd>A fixed size buffer can be used for the container, which eliminates queue memory management happening during a <code>push</code> or <code>pop</code>. In particular, the proposed <code>std::ring_span</code> container (C++ 20, most likely) works well for this use case, and this code has been tested with <code>ring-span</code> lite from Martin Moene. The constructor that takes an iterator range can be used for a container view type, which means that the <code>wait_queue</code> owns and manages a view rather than the underlying container buffer.</dd>
<dd>
The <code>boost</code> <code>circular_buffer</code> can be used for the container type. Memory is allocated only once, at container construction time. This may be useful for environments where construction can be dynamic, but a <code>push</code> or <code>pop</code> must not allocate or deallocate memory.</dd>
<dd>
If the container type is <code>boost</code> <code>circular_buffer</code> then the default constructor for <code>wait_queue</code> cannot be used (since it would result in a container with an empty capacity).</dd>
<dd>
Iterators are not supported, due to obvious difficulties with maintaining consistency and integrity. The <code>apply</code> method can be used to access the internal data in a threadsafe manner.</dd>
<dd>
Copy and move construction or assignment for the whole queue is disallowed, since the use cases and underlying implications are not clear for those operations. In particular, the exception implications for assigning the internal data from one queue to another is messy, and the general semantics of what it means is not clearly defined. If there is data in one <code>wait_queue</code> that must be copied or moved to another, the <code>apply</code> method can be used or individual <code>push</code> and <code>pop</code> methods called, even if not as efficient as an internal copy or move.</dd>
<dd>
Very few methods are declared as <code>noexcept</code> since very few of the <code>std::mutex</code>, <code>std::condition_variable</code>, and <code>std::lock_guard</code> methods are <code>noexcept</code>. It is possible to declare the methods as conditionally <code>noexcept</code> (commented out code), which would assume that no exceptions will escape from mutex or condition variable objects (or if one does, <code>std::terminate</code> will be called).</dd></dl>
<dl class="section author"><dt>Authors</dt><dd>Cliff Green, Anthony Williams</dd></dl>
<p>Copyright (c) 2017-2018 by Cliff Green</p>
<p>Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>) </p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
